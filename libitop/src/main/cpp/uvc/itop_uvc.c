/* DO NOT EDIT THIS FILE - it is machine generated */
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <asm/types.h>
#include <linux/videodev2.h>
#include <sys/mman.h>
#include <string.h>
#include <malloc.h>
#include <linux/fb.h>
#include <jni.h>
#include <syslog.h>
#include <android/log.h>

#include "libavcodec/avcodec.h"
#include "libavformat/avformat.h"
#include "libswscale/swscale.h"
#include "itop_uvc.h"

#define  LOG_TAG    "ITOP_UVC"
#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , LOG_TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO   , LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN   , LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__)

struct fimc_buffer {
    unsigned char *start;
    size_t length;
};

static int fd = -1;
struct fimc_buffer *buffers = NULL;
struct v4l2_buffer v4l2_buf;
static int bufnum = 1;
static int mwidth, mheight;

/* Header for class com_jiangyt_library_libitop_UvcCamera */
#undef TCSAFLUSH
#define TCSAFLUSH TCSETSF
#ifndef _TERMIOS_H_
#define _TERMIOS_H_
#endif
/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    open
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_open
        (JNIEnv *env, jclass obj, jint devid) {
    char *devname;
    switch (devid) {
        case 0:
            devname = "/dev/video0";
            break;
        case 1:
            devname = "/dev/video1";
            break;
        case 2:
            devname = "/dev/video2";
            break;
        case 3:
            devname = "/dev/video3";
            break;
        case 11:
            devname = "/dev/video11";
            break;
        case 12:
            devname = "/dev/video12";
            break;
        case 16:
            devname = "/dev/video16";
            break;
        case 20:
            devname = "/dev/video20";
            break;
        default:
            devname = "/dev/video4";
            break;
    }
    devname = "/dev/video3";
    fd = open(devname, O_RDWR);

    if (fd < 0)
        LOGE("%s ++++ open error\n", devname);
    return fd;
}

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    init
 * Signature: (III)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_init
        (JNIEnv *env, jclass obj, jint width, jint height, jint numbuf) {
    int ret;
    int i;
    bufnum = numbuf;
    mwidth = width;
    mheight = height;
    struct v4l2_format fmt;
    struct v4l2_capability cap;

    ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
    if (ret < 0) {
        LOGE("%d :VIDIOC_QUERYCAP failed\n", __LINE__);
        return -1;
    }
    if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
        LOGE("%d : no capture devices\n", __LINE__);
        return -1;
    }

    memset(&fmt, 0, sizeof(fmt));
    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
    fmt.fmt.pix.width = width;
    fmt.fmt.pix.height = height;
    if (ioctl(fd, VIDIOC_S_FMT, &fmt) < 0) {
        LOGE("++++%d : set format failed\n", __LINE__);
        return -1;
    }

    struct v4l2_requestbuffers req;
    req.count = numbuf;
    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    req.memory = V4L2_MEMORY_MMAP;

    ret = ioctl(fd, VIDIOC_REQBUFS, &req);
    if (ret < 0) {
        LOGE("++++%d : VIDIOC_REQBUFS failed\n", __LINE__);
        return -1;
    }

    buffers = calloc(req.count, sizeof(*buffers));
    if (!buffers) {
        LOGE ("++++%d Out of memory\n", __LINE__);
        return -1;
    }

    for (i = 0; i < bufnum; ++i) {
        memset(&v4l2_buf, 0, sizeof(v4l2_buf));
        v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        v4l2_buf.memory = V4L2_MEMORY_MMAP;
        v4l2_buf.index = i;
        ret = ioctl(fd, VIDIOC_QUERYBUF, &v4l2_buf);
        if (ret < 0) {
            LOGE("+++%d : VIDIOC_QUERYBUF failed\n", __LINE__);
            return -1;
        }
        buffers[i].length = v4l2_buf.length;
        if ((buffers[i].start = (char *) mmap(0, v4l2_buf.length,
                                              PROT_READ | PROT_WRITE, MAP_SHARED,
                                              fd, v4l2_buf.m.offset)) < 0) {
            LOGE("%d : mmap() failed", __LINE__);
            return -1;
        }
    }
    return 0;
}

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    streamon
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_streamon
        (JNIEnv *env, jclass obj) {
    int i;
    int ret;
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    for (i = 0; i < bufnum; ++i) {
        memset(&v4l2_buf, 0, sizeof(v4l2_buf));
        v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        v4l2_buf.memory = V4L2_MEMORY_MMAP;
        v4l2_buf.index = i;
        ret = ioctl(fd, VIDIOC_QBUF, &v4l2_buf);
        if (ret < 0) {
            LOGE("%d : VIDIOC_QBUF failed\n", __LINE__);
            return ret;
        }
    }
    ret = ioctl(fd, VIDIOC_STREAMON, &type);
    if (ret < 0) {
        LOGE("%d : VIDIOC_STREAMON failed\n", __LINE__);
        return ret;
    }
    return 0;
}

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    dqbuf
 * Signature: ([B)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_dqbuf
        (JNIEnv *env, jclass obj, jbyteArray videodata) {
    int ret;

    jbyte *data = (jbyte *) (*env)->GetByteArrayElements(env, videodata, 0);
    v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    v4l2_buf.memory = V4L2_MEMORY_MMAP;

    ret = ioctl(fd, VIDIOC_DQBUF, &v4l2_buf);
    if (ret < 0) {
        LOGE("%s : VIDIOC_DQBUF failed, dropped frame\n", __func__);
        return ret;
    }
    memcpy(data, buffers[v4l2_buf.index].start, buffers[v4l2_buf.index].length);
    (*env)->ReleaseByteArrayElements(env, videodata, data, 0);
    return v4l2_buf.index;
}


/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    yuvtorgb
 * Signature: ([B[BII)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_yuvtorgb
        (JNIEnv *env, jclass obj, jbyteArray yuvdata, jbyteArray rgbdata, jint dwidth,
         jint dheight) {
    jbyte *ydata = (jbyte *) (*env)->GetByteArrayElements(env, yuvdata, 0);
    jbyte *rdata = (jbyte *) (*env)->GetByteArrayElements(env, rgbdata, 0);
    AVFrame *rpicture = NULL;
    AVFrame *ypicture = NULL;
    struct SwsContext *swsctx = NULL;
    rpicture = av_frame_alloc();
    ypicture = av_frame_alloc();
    avpicture_fill((AVPicture *) rpicture, (uint8_t *) rdata, AV_PIX_FMT_RGB565, dwidth, dheight);
    avpicture_fill((AVPicture *) ypicture, (uint8_t *) ydata, AV_PIX_FMT_YUYV422, mwidth, mheight);
    swsctx = sws_getContext(mwidth, mheight, AV_PIX_FMT_YUYV422, dwidth, dheight, AV_PIX_FMT_RGB565,
                            SWS_BICUBIC, NULL, NULL, NULL);
    sws_scale(swsctx, (const uint8_t *const *) ypicture->data, ypicture->linesize, 0, mheight,
              rpicture->data, rpicture->linesize);
    sws_freeContext(swsctx);
    av_free(rpicture);
    av_free(ypicture);
    (*env)->ReleaseByteArrayElements(env, yuvdata, ydata, 0);
    (*env)->ReleaseByteArrayElements(env, rgbdata, rdata, 0);
    return 0;
}

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    qbuf
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_qbuf
        (JNIEnv *env, jclass obj, jint index) {
    int ret;

    v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    v4l2_buf.memory = V4L2_MEMORY_MMAP;
    v4l2_buf.index = index;

    ret = ioctl(fd, VIDIOC_QBUF, &v4l2_buf);
    if (ret < 0) {
        LOGE("%s : VIDIOC_QBUF failed\n", __func__);
        return ret;
    }

    return 0;
}

AVCodecContext *pCodecCtx = NULL;
AVPacket avpkt;
FILE *video_file;
unsigned char *outbuf = NULL;
unsigned char *yuv420buf = NULL;
static int outsize = 0;

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    videoinit
 * Signature: ([B)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_videoinit
        (JNIEnv *env, jclass obj, jbyteArray filename) {
    LOGI("%s\n", __func__);
    AVCodec *pCodec = NULL;
    avcodec_register_all();
    pCodec = avcodec_find_encoder(AV_CODEC_ID_MPEG1VIDEO);
    if (pCodec == NULL) {
        LOGE("++++++++++++codec not found\n");
        return -1;
    }
    pCodecCtx = avcodec_alloc_context3(pCodec);
    if (pCodecCtx == NULL) {
        LOGE("++++++Could not allocate video codec context\n");
        return -1;
    }
    /* put sample parameters */
    pCodecCtx->bit_rate = 400000;
    /* resolution must be a multiple of two */
    pCodecCtx->width = mwidth;
    pCodecCtx->height = mheight;
    /* frames per second */
    pCodecCtx->time_base = (AVRational) {1, 25};
    pCodecCtx->gop_size = 10; /* emit one intra frame every ten frames */
    pCodecCtx->max_b_frames = 1;
    pCodecCtx->pix_fmt = AV_PIX_FMT_YUV420P;//AV_PIX_FMT_YUYV422;
    /* open it */
    if (avcodec_open2(pCodecCtx, pCodec, NULL) < 0) {
        LOGE("+++++++Could not open codec\n");
        return -1;
    }
    outsize = mwidth * mheight * 2;
    outbuf = malloc(outsize * sizeof(char));
    yuv420buf = malloc(outsize * sizeof(char));
    jbyte *filedir = (jbyte *) (*env)->GetByteArrayElements(env, filename, 0);
    if ((video_file = fopen(filedir, "wb")) == NULL) {
        LOGE("++++++++++++open %s failed\n", filedir);
        return -1;
    }
    (*env)->ReleaseByteArrayElements(env, filename, filedir, 0);
    return 1;
}
/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    videostart
 * Signature: ([B)I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_videostart
        (JNIEnv *env, jclass obj, jbyteArray yuvdata) {
    int frameFinished = 0, size = 0;
    jbyte *ydata = (jbyte *) (*env)->GetByteArrayElements(env, yuvdata, 0);
    AVFrame *yuv420pframe = NULL;
    AVFrame *yuv422frame = NULL;
    struct SwsContext *swsctx = NULL;
    yuv420pframe = av_frame_alloc();
    yuv422frame = av_frame_alloc();
    avpicture_fill((AVPicture *) yuv420pframe, (uint8_t *) yuv420buf, AV_PIX_FMT_YUV420P, mwidth,
                   mheight);
    avpicture_fill((AVPicture *) yuv422frame, (uint8_t *) ydata, AV_PIX_FMT_YUYV422, mwidth,
                   mheight);
    swsctx = sws_getContext(mwidth, mheight, AV_PIX_FMT_YUYV422, mwidth, mheight,
                            AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);
    sws_scale(swsctx, (const uint8_t *const *) yuv422frame->data, yuv422frame->linesize, 0, mheight,
              yuv420pframe->data, yuv420pframe->linesize);
    av_init_packet(&avpkt);
    size = avcodec_encode_video2(pCodecCtx, &avpkt, yuv420pframe, &frameFinished);
    if (size < 0) {
        LOGE("+++++Error encoding frame\n");
        return -1;
    }
    if (frameFinished)
        fwrite(avpkt.data, avpkt.size, 1, video_file);
    av_free_packet(&avpkt);
    sws_freeContext(swsctx);
    av_free(yuv420pframe);
    av_free(yuv422frame);
    (*env)->ReleaseByteArrayElements(env, yuvdata, ydata, 0);
}

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    videoclose
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_videoclose
        (JNIEnv *env, jclass obj) {
    fclose(video_file);
    avcodec_close(pCodecCtx);
    av_free(pCodecCtx);
    free(outbuf);
}

/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    streamoff
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_streamoff
        (JNIEnv *env, jclass obj) {
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int ret;

    ret = ioctl(fd, VIDIOC_STREAMOFF, &type);
    if (ret < 0) {
        LOGE("%s : VIDIOC_STREAMOFF failed\n", __func__);
        return ret;
    }

    return 0;
}
/*
 * Class:     com_jiangyt_library_libitop_UvcCamera
 * Method:    release
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_jiangyt_library_libitop_UvcCamera_release
        (JNIEnv *env, jclass obj) {
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int ret;
    int i;

    ret = ioctl(fd, VIDIOC_STREAMOFF, &type);
    if (ret < 0) {
        LOGE("%s : VIDIOC_STREAMOFF failed\n", __func__);
        return ret;
    }

    for (i = 0; i < bufnum; i++) {
        ret = munmap(buffers[i].start, buffers[i].length);
        if (ret < 0) {
            LOGE("%s : munmap failed\n", __func__);
            return ret;
        }
    }
    free(buffers);
    close(fd);
    return 0;
}

